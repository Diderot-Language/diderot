(* stamp.sml
 *
 * Stamps are locally unique identifiers used in the compiler to
 * distinguish different types, variables, etc.  For a given compilation,
 * the stamp assigned to an object is guaranteed to be unique, although
 * an object may have different stamps assigned to it in different compiles.
 *
 * COPYRIGHT (c) 2016 John Reppy (http://cs.uchicago.edu/~jhr)
 *
 * Permission is hereby granted, free of charge, to any person obtaining a copy
 * of this software and associated documentation files (the "Software"), to deal
 * in the Software without restriction, including without limitation the rights
 * to use, copy, modify, merge, publish, distribute, sublicense, and/or sell
 * copies of the Software, and to permit persons to whom the Software is
 * furnished to do so, subject to the following conditions:
 *
 * The above copyright notice and this permission notice shall be included in all
 * copies or substantial portions of the Software.
 *
 * THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR
 * IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,
 * FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE
 * AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER
 * LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,
 * OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
 * SOFTWARE.
 *
 * This file is part of the SML Compiler Utilities, which can be found at
 *
 *      https://github.com/JohnReppy/sml-compiler-utils
 *)

structure Stamp :> sig

    type t

  (* a distinguished stamp that will never be generated by `new` *)
    val zero : t

  (* generate a new stamp *)
    val new : unit -> t

  (* `reset stmp` resets the stamp generator while preserving any stamp
   * that was generated upto and including stmp.  This function should
   * be used with care, since it invalidates the uniqueness invariant of
   * any stamps that were generated after `stmp`.  Use `reset zero` to
   * completely reset the stamp generator.
   *)
    val reset : t -> unit

  (* stamp equality test *)
    val same    : (t * t) -> bool
  (* compare two stamps *)
    val compare : (t * t) -> order
  (* hash a stamp *)
    val hash    : t -> word

  (* string representation of a stamp; this will be a four-digit hex number
   * padded with leading zeros.
   *)
    val toString : t -> string

  (* sets, maps, and hash tables keyed by stamps *)
    structure Set : ORD_SET where type Key.ord_key = t
    structure Map : ORD_MAP where type Key.ord_key = t
    structure Tbl : MONO_HASH_TABLE where type Key.hash_key = t

  end = struct

    structure W = Word

    datatype t = STAMP of {
        id : Word.word
      }

    val zero = STAMP{id=0w0}

    val cnt = ref 0w1

    fun new () = let val w = !cnt in cnt := w+0w1; STAMP{id = w} end

    fun reset (STAMP{id}) = cnt := id

    fun same (STAMP{id, ...}, STAMP{id=id', ...}) = (id = id')
    fun compare (STAMP{id, ...}, STAMP{id=id', ...}) = W.compare(id, id')
    fun hash (STAMP{id, ...}) = id

    fun toString (STAMP{id, ...}) = StringCvt.padLeft #"0" 4 (W.toString id)

    structure Key =
      struct
        type ord_key = t
        val compare = compare
      end
    structure Map = RedBlackMapFn (Key)
    structure Set = RedBlackSetFn (Key)

    structure Tbl = HashTableFn (struct
        type hash_key = t
        fun hashVal (STAMP{id}) = id
        fun sameKey (STAMP{id=a}, STAMP{id=b}) = (a = b)
      end)

  end

